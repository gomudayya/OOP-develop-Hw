* 두 반복자 모두 커서 개념을 이용한다. 배열 기반 리스트에서는 커서는 색인값이며, 연결구조에서는 노드를
가리키는 참조가 커서가 된다. 배열 기반 리스트에서 커서는 0으로 초기화되며, 연결구조에서는 첫 번째 노드
head로 초기화된다.

* next: 다음 요소를 반환하고, 커서를 다음 위치로 이동함. 예) [2,3,5]에서 next를 연속적으로 호출하면 2, 3,
5를 차례로 반환한다. 더 이상 제공할 요소가 없으면 NoSuchElementException을 발생한다.

* prev: 이전 요소를 반환하고, 커서를 이전 위치로 이동함. [2,3,5]에서 next가 5를 반환한 후에 연속하여
prev를 부르면 5, 3, 2를 반환하여야 한다. next, prev를 번걸아 호출하면 계속 동일 값을 주어야 한다. 더
이상 제공할 요소가 없으면 NoSuchElementException을 발생한다.

* nextIndex: next 메소드가 호출하면 반환할 요소의 색인을 반환함. 커서가 맨 뒤에 있으면 리스트의 크기를
반환함

* previousIndex: prev 메소드가 호출하면 반환할 요소의 색인을 반환함. 커서가 맨 앞에 있으면 −1을
반환함

* set: 이전 next()나 previous() 호출에서 반환된 요소를 교체한다. next()나 previous() 호출 이후
add()나 remove()가 호출되었으면 실행하지 않고 예외(IllegalStateException)를 발생해야 한다.

   * 예) [2, 3, 5]에서 next() 호출로 첫 번째 2를 받은 후 set(4)를 호출하면 [4, 3, 5]가 되어야 한다.
* add: next()를 호출하였을 때 반환할 요소 앞에 추가한다. add 이후 next()의 호출은 add 하지 않은
경우와 차이가 없어야 한다.

    * 예) [2, 3, 5]에서 next() 호출로 첫 번째 2를 받은 후 add(4)를 호출하면 [2, 4, 3, 5]가 되어야 하며,
    그다음 next()가 호출되면 3을 반환하여야 한다.

* remove: 이전 next()나 previous() 호출에서 반환된 요소를 제거한다. next()나 previous() 호출
이후 한 번만 실행 가능하다. next()나 previous() 호출 이후 add()나 remove()가 호출되면 실행하지
않고 예외(IllegalStateException)를 발생해야 한다.

    * 예) [2, 3, 5]에서 next() 호출로 첫 번째 2를 받은 후 remove()를 호출하면 [3, 5]가 되어야 하며 
    그다음 next()가 호출되면 3을 반환하여야 한다.

* 연결구조에서는 커서를 색인으로 사용하지 않지만 nextIndex, previousIndex의 구현을 위해서는 배열
기반 리스트와 유사하게 색인을 유지해야 한다.
